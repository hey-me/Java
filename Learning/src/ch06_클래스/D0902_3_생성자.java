package ch06_클래스;
public class D0902_3_생성자 {
	public static void main(String[] args) {				   
/*	*생성자  (대문자!!!! <-> 메소드는 소문자)
		- 생성자는 new연산자로 호출되는 중괄호{} 블록.
		- 객체 생성시 초기화를 담당.
		- **리턴 타입 없음.
	
	*기본 생성자 (default constructor)
		- 클래스 내부에 생성자 선언을 생략할 경우 바이트 코드에 자동으로 추가.
		- 클래스이름(){}; (적어도 되고 안 적어도 됨. java compiler가 자동으로 만들어줌.)
		- 매개변수가 있는 기본 생성자(_클래스이름(변수){};_)를 만들어 버리면 자동으로 컴파일이 안됨.
			=> 호출시 괄호()안에 변수를 입력하거나, 클래스이름(){};를 하나 더 작성해줌. 
		
	*생성자 선언 (생성자 정의)
		- 매개변수 선언은 생략할 수도 있고(기본생성자 자동생성) 여러개 선언할 수도 있음.
		- 클래스에 생성자가 명시적으로 선언되었을 경우 반드시 선언된 생성자 호출하여 객체 생성 
	
	*객체 초기화
		- 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 하는 것
	
	**오버로딩 -... 생성자 오버로딩
		- 같은 이름의 메소드를 여러번 정의하는 것.
		- 호출시 다양하게 사용하려고 만듦.
		- 외부에서 제공되는 다양한 데이터를 사용하여 객체화하기 위해.
		- 매개변수의 타입, 개수, 순서가 다름.
	
	**this
		- 인스턴스 될때 주소가 무엇인지 모르는 경우에 주소를 참조할 수 있음.
		- 참조변수를 따로 지정하여 사용하지 않고 this라는 참조변수 이용하여 참조 가능.  
			=> Car c = new Car();  => c에 주소 안 올리고 this.으로 바로 사용 가능.
		-필드와 매개 변수의 이름이 완전히 동일할 경우 this. 필드로 표현 
			ex) String name;
		 		String model;
		 		Car(String name){name = name};  
		 			=> 필드의 name과 메소드의 name을 구분하고 싶다
		 			=> Car(String name){this.name = name};
		 			
	**this() 코드
		- 생성자에서 다른 생성자를 호출
		- 필드 초기화한 내용을 한 생성자에만 집중 작성하고 나머지 생성자는 초기화 내용 가진 생성자로 호출
		- 생성자 오버로딩 증가 시 중복 코드 발생 문제 해결
		*-* 생성자의 첫 줄에서만 허용
__________________________________________________________________________________
	
	Scanner s = new Scanner(System.in);
		=> 생성자 메소드
		앞과 뒤는 같은 타입이어야 한다.

	Abc a = new Abc(); // a는 참조변수.
		뒤에 있는 Abc메소드를 앞에 있는 Abc클래스에 넣는것

	a.add(5, 10);  ** 점 찍어서 가져다 사용
*/
 
	}
	class Abc {
		int add(int a, int b) {
			return a + b;
		}
	}
}
