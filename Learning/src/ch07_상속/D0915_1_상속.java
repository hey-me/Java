package ch07_상속;

public class D0915_1_상속 {

	public static void main(String[] args) {
/*
	* 상속 : 이미 개발된 클래스를 재사용하여 코드 중복을 방지 (여러 클래스의 생성자, 필드 비슷할 때)
		- 원래의 기능이 있지만 그 기능을 수정하여 이용.
			- 슈퍼클래스, 상위클래스  <=>  하위클래스
			- 상위클래스의 메소드를 하위클래스에 똑같이 만들고 { }안의 내용만 다르게 => 재정의
			- class 자식클래스 extends 부모클래스 { } 
			- 여러개의 부모클래스 상속x
			- 부모클래스에서 private 필드와 메소드는 상속 대상에서 제외.
			- 부모와 자식 클래스가 다른 패키지에 존재할 경우 default 접근 제한된 필드와 메소드 역시 제외. 사용하려면 public 사용하기
			- 자식 객체 생성시 부모 객체 먼저 생성됨.
				*->자식생성자의 첫 줄에 부모 생성자가 호출됨. super();
				*-default생성자 만들어주기~~
			
					
	* 메소드 재정의 (method overriding)...상속이 되어야만 사용 가능.
		- 부모클래스의 코드의 변경이 필요할 때 자식클래스에서 재작성, 재정의
		- 자식 객체에서 메소드 호출하면 재정의된 자식 메소드가 호출됨. 
		- 앞은 모두 같고 { }안에만 다름.
	
	
	* final : 해당 선언이 최종 상태이며 수정될 수 없음.
	
	* final 클래스 : 상속 불가...부모클래스가 될 수 없어 자식클래스를 만들 수 없음. 
		
	* final 메소드 : 오버라이딩 불가...부모클래스에 선언된 final메소드는 자식클래스에서 재정의 할 수 없음. 
 
 
	*출력시 toString메소드 말고 그냥 참조변수로 출력 가능.
		javaTeacher.d0910.ex4 (객체지향문제4) 참조	
		@Override 
		public String toString() {
			return "[ Marine의 위치는 ("+x+", "+y+")이고, 체력은 "+
					hp+", "+"공격력은 "+weapon+", "+"방어력은 "+
					armor+" 입니다. ]";
				
		Marine m1=new Marine();
		System.out.println(m1.toString); 이렇게 메소드 출력 안하고
		System.out.println(m1); 참조변수만 출력해도 됨.
		
		
*/
	}

}
